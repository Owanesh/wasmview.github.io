{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from 'react';\nimport Row from 'react-bootstrap/Row';\nimport Col from 'react-bootstrap/Col';\nconst colorScale = {\n  WASM_EXPORT: {\n    fill: '#1892C7',\n    font: '#FFFFFF'\n  },\n  WASM_IMPORT: {\n    fill: '#FF6939',\n    font: '#FFFFFF'\n  },\n  WASM_INTERNAL: {\n    fill: '#000000',\n    font: '#FFFFFF'\n  },\n  WASM_WORKER: {\n    fill: '#1892C7',\n    font: '#FFFFFF'\n  },\n  JS: {\n    fill: '#cccccc',\n    font: '#000000'\n  }\n};\nconst grayScale = {\n  WASM_EXPORT: {\n    fill: '#000000',\n    font: '#FFFFFF'\n  },\n  WASM_IMPORT: {\n    fill: '#969696',\n    font: '#FFFFFF'\n  },\n  WASM_INTERNAL: {\n    fill: '#cccccc',\n    font: '#000000'\n  },\n  WASM_WORKER: {\n    fill: '#000000',\n    font: '#FFFFFF'\n  },\n  JS: {\n    fill: '#636363',\n    font: '#FFFFFF'\n  }\n};\nexport default class GraphComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      graphOptions: {\n        combineWorkersAndWindow: true,\n        tooLarge: false,\n        useGrayscale: false\n      }\n    };\n    this.graphRef = React.createRef();\n    this.handleCheckboxChange = this.handleCheckboxChange.bind(this);\n    this.svgPanZoom = null;\n  }\n\n  handleCheckboxChange() {\n    const isChecked = this.state.graphOptions.useGrayscale;\n\n    const newGraphOptions = _objectSpread({}, this.state.graphOptions);\n\n    newGraphOptions.useGrayscale = !isChecked;\n    this.setState({\n      graphOptions: newGraphOptions\n    });\n  }\n\n  initGraph() {\n    var container = this.graphRef.current;\n    let model = new mxGraphModel();\n    this.graph = new mxGraph(container, model);\n    const graph = this.graph;\n    graph.setPanning(false);\n    graph.setEnabled(false);\n    graph.autoSizeCellsOnAdd = true;\n    const colorsToUse = this.state.graphOptions.useGrayscale ? grayScale : colorScale;\n\n    const commonFunctionStyle = () => {\n      var style = new Object();\n      style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n      style[mxConstants.STYLE_AUTOSIZE] = '1';\n      style[mxConstants.STYLE_SPACING] = '20'; // style[mxConstants.STYLE_SPACING_TOP] = '2';\n      // style[mxConstants.STYLE_SPACING_BOTTOM] = '2';\n\n      style[mxConstants.STYLE_MOVABLE] = '1';\n      style[mxConstants.STYLE_FONTSIZE] = '20';\n      style[mxConstants.STYLE_FONTSTYLE] = mxConstants.FONT_BOLD;\n      style[mxConstants.STYLE_FONTFAMILY] = 'Arial';\n      return style;\n    };\n\n    var wasmExportFunctionStyle = commonFunctionStyle();\n    wasmExportFunctionStyle[mxConstants.STYLE_FILLCOLOR] = colorsToUse['WASM_EXPORT'].fill;\n    wasmExportFunctionStyle[mxConstants.STYLE_STROKECOLOR] = '#FFFFFF';\n    wasmExportFunctionStyle[mxConstants.STYLE_FONTCOLOR] = colorsToUse['WASM_EXPORT'].font;\n    graph.getStylesheet().putCellStyle('WASM_EXPORT', wasmExportFunctionStyle);\n    var wasmImportFunctionStyle = commonFunctionStyle();\n    wasmImportFunctionStyle[mxConstants.STYLE_FILLCOLOR] = colorsToUse['WASM_IMPORT'].fill;\n    wasmImportFunctionStyle[mxConstants.STYLE_STROKECOLOR] = '#FFFFFF';\n    wasmImportFunctionStyle[mxConstants.STYLE_FONTCOLOR] = colorsToUse['WASM_IMPORT'].font;\n    graph.getStylesheet().putCellStyle('WASM_IMPORT', wasmImportFunctionStyle);\n    var wasmInternalFunctionStyle = commonFunctionStyle();\n    wasmInternalFunctionStyle[mxConstants.STYLE_FILLCOLOR] = colorsToUse['WASM_INTERNAL'].fill;\n    wasmInternalFunctionStyle[mxConstants.STYLE_STROKECOLOR] = '#FFFFFF';\n    wasmInternalFunctionStyle[mxConstants.STYLE_FONTCOLOR] = colorsToUse['WASM_INTERNAL'].font;\n    graph.getStylesheet().putCellStyle('WASM_INTERNAL', wasmInternalFunctionStyle);\n    var wasmWorkerFunctionStyle = commonFunctionStyle();\n    wasmWorkerFunctionStyle[mxConstants.STYLE_FILLCOLOR] = colorsToUse['WASM_WORKER'].fill;\n    wasmWorkerFunctionStyle[mxConstants.STYLE_STROKECOLOR] = '#FFFFFF';\n    wasmWorkerFunctionStyle[mxConstants.STYLE_FONTCOLOR] = colorsToUse['WASM_WORKER'].font;\n    graph.getStylesheet().putCellStyle('WASM_WORKER', wasmWorkerFunctionStyle);\n    var jsFunctionStyle = commonFunctionStyle();\n    jsFunctionStyle[mxConstants.STYLE_FILLCOLOR] = colorsToUse['JS'].fill;\n    jsFunctionStyle[mxConstants.STYLE_STROKECOLOR] = '#FFFFFF';\n    jsFunctionStyle[mxConstants.STYLE_FONTCOLOR] = colorsToUse['JS'].font;\n    graph.getStylesheet().putCellStyle('JS', jsFunctionStyle);\n    return graph;\n  }\n\n  drawGraph() {\n    var container = this.graphRef.current;\n    const {\n      combineWorkersAndWindow\n    } = this.state.graphOptions;\n    const {\n      details\n    } = this.props;\n    const windowDetails = details.window;\n    const workers = details.workers;\n    const vertexDimensions = [0, 0, 100, 50];\n\n    if (windowDetails == null) {\n      return __jsx(\"span\", null);\n    }\n\n    const exportCalls = windowDetails.exportCalls;\n    const importCalls = windowDetails.importCalls;\n    let graph;\n\n    if (this.graph == null) {\n      graph = this.initGraph();\n    } else {\n      graph = this.graph;\n      graph.removeCells(graph.getChildCells(graph.getDefaultParent(), true, true));\n      graph = null;\n      graph = this.initGraph();\n    }\n\n    const model = graph.getModel();\n    var parent = graph.getDefaultParent();\n    var layout = new mxHierarchicalLayout(graph);\n    layout.interRankCellSpacing = 100;\n    model.beginUpdate();\n    const allNodesCombined = {};\n\n    const addKeyFunctions = (functionName, parentVertex, leafStyle) => {\n      let vertex;\n\n      if (allNodesCombined[functionName] == null) {\n        vertex = graph.insertVertex(parentVertex, null, `${functionName}()`, ...vertexDimensions, leafStyle);\n        allNodesCombined[functionName] = vertex;\n      } else {\n        vertex = allNodesCombined[functionName];\n      }\n    };\n\n    const addToGraph = (functionName, edgesForFunction, parentVertex, leafStyle) => {\n      let vertex;\n      const allNodesSeparate = {};\n      const edgeList = edgesForFunction;\n\n      if (combineWorkersAndWindow) {\n        if (allNodesCombined[functionName] == null) {\n          vertex = graph.insertVertex(parentVertex, null, `${functionName}()`, ...vertexDimensions, leafStyle);\n          allNodesCombined[functionName] = vertex;\n        } else {\n          vertex = allNodesCombined[functionName];\n        }\n      } else {\n        if (allNodesSeparate[functionName] == null) {\n          vertex = graph.insertVertex(parentVertex, null, `${functionName}()`, ...vertexDimensions, leafStyle);\n          allNodesSeparate[functionName] = vertex;\n        } else {\n          vertex = allNodesSeparate[functionName];\n        }\n      }\n\n      for (const edges of edgeList) {\n        let previousFunction;\n\n        for (let stackFunctionName of edges) {\n          let jsStyle = 'JS';\n\n          if (stackFunctionName.includes('wasm-function___')) {\n            jsStyle = 'WASM_INTERNAL';\n            stackFunctionName = stackFunctionName.replace('wasm-function___', '');\n          }\n\n          let currentFunction = combineWorkersAndWindow ? allNodesCombined[stackFunctionName] : allNodesSeparate[stackFunctionName];\n\n          if (currentFunction == null) {\n            currentFunction = graph.insertVertex(parentVertex, null, `${stackFunctionName}()`, ...vertexDimensions, jsStyle);\n\n            if (combineWorkersAndWindow) {\n              allNodesCombined[stackFunctionName] = currentFunction;\n            } else {\n              allNodesSeparate[stackFunctionName] = currentFunction;\n            }\n          }\n\n          if (previousFunction != null) {\n            const currentEdges = currentFunction.edges;\n            const previousEdges = previousFunction.edges;\n            let alreadyInGraph = false;\n\n            if (currentEdges != null) {\n              for (const edge of currentEdges) {\n                if (edge.target.value === previousFunction.value) {\n                  // debugger;\n                  alreadyInGraph = true;\n                }\n              }\n            }\n\n            if (!alreadyInGraph) {\n              graph.insertEdge(parentVertex, null, '', currentFunction, previousFunction);\n            }\n\n            previousFunction = currentFunction;\n          } else {\n            previousFunction = currentFunction;\n          }\n        }\n      }\n    };\n\n    for (const scopeInstrumentationRecords of [windowDetails, ...workers]) {\n      const wasmFileHashes = _Object$keys(scopeInstrumentationRecords.WasmFiles);\n\n      for (const wasmFileHash of wasmFileHashes) {\n        const wasmRecordedCallDetails = scopeInstrumentationRecords.WasmFiles[wasmFileHash];\n        const debugFunctionNames = wasmRecordedCallDetails.functionNameObjects;\n        const wasmExportCalls = wasmRecordedCallDetails.exportCalls;\n        const wasmImportCalls = wasmRecordedCallDetails.importCalls;\n\n        const exportFuntionNames = _Object$keys(wasmExportCalls);\n\n        const importFuntionNames = _Object$keys(wasmImportCalls);\n\n        if (combineWorkersAndWindow) {\n          for (const exportFuntionName of exportFuntionNames) {\n            addKeyFunctions(exportFuntionName, parent, 'WASM_EXPORT');\n          }\n        } //Need to be sliced and formatted\n\n\n        for (const exportFuntionName of exportFuntionNames) {\n          const edgeList = wasmExportCalls[exportFuntionName];\n          addToGraph(exportFuntionName, edgeList, parent, 'WASM_EXPORT');\n        }\n\n        if (combineWorkersAndWindow) {\n          for (const importFuntionName of importFuntionNames) {\n            addKeyFunctions(importFuntionName, parent, 'WASM_IMPORT');\n          }\n        }\n\n        for (const importFuntionName of importFuntionNames) {\n          const edgeList = wasmImportCalls[importFuntionName];\n          addToGraph(importFuntionName, edgeList, parent, 'WASM_IMPORT');\n        }\n      }\n    }\n\n    model.endUpdate();\n    layout.execute(parent);\n  }\n\n  componentDidMount() {\n    this.drawGraph();\n    var container = this.graphRef.current.children[0];\n    let eventsHandler = {\n      haltEventListeners: ['touchstart', 'touchend', 'touchmove', 'touchleave', 'touchcancel'],\n      init: function (options) {\n        var instance = options.instance,\n            initialScale = 1,\n            pannedX = 0,\n            pannedY = 0; // Init Hammer\n        // Listen only for pointer and touch events\n\n        this.hammer = Hammer(options.svgElement, {\n          inputClass: Hammer.SUPPORT_POINTER_EVENTS ? Hammer.PointerEventInput : Hammer.TouchInput\n        }); // Enable pinch\n\n        this.hammer.get('pinch').set({\n          enable: true\n        }); // Handle double tap\n\n        this.hammer.on('doubletap', function (ev) {\n          instance.zoomIn();\n        }); // Handle pan\n\n        this.hammer.on('panstart panmove', function (ev) {\n          // On pan start reset panned variables\n          if (ev.type === 'panstart') {\n            pannedX = 0;\n            pannedY = 0;\n          } // Pan only the difference\n\n\n          instance.panBy({\n            x: ev.deltaX - pannedX,\n            y: ev.deltaY - pannedY\n          });\n          pannedX = ev.deltaX;\n          pannedY = ev.deltaY;\n        }); // Handle pinch\n\n        this.hammer.on('pinchstart pinchmove', function (ev) {\n          // On pinch start remember initial zoom\n          if (ev.type === 'pinchstart') {\n            initialScale = instance.getZoom();\n            instance.zoomAtPoint(initialScale * ev.scale, {\n              x: ev.center.x,\n              y: ev.center.y\n            });\n          }\n\n          instance.zoomAtPoint(initialScale * ev.scale, {\n            x: ev.center.x,\n            y: ev.center.y\n          });\n        }); // Prevent moving the page on some devices when panning over SVG\n\n        options.svgElement.addEventListener('touchmove', function (e) {\n          e.preventDefault();\n        });\n      },\n      destroy: function () {\n        this.hammer.destroy();\n      }\n    };\n    this.svgPanZoom = svgPanZoom(container, {\n      zoomScaleSensitivity: 0.2,\n      minZoom: 0.2,\n      contain: true,\n      customEventsHandler: eventsHandler\n    });\n  }\n\n  render() {\n    const {\n      graphOptions\n    } = this.state;\n    const {\n      combineWorkersAndWindow,\n      tooLarge,\n      useGrayscale\n    } = graphOptions;\n    const isChecked = useGrayscale === true;\n    return __jsx(\"div\", null, __jsx(\"h4\", null, \"JS/Wasm Interaction Graph\"), __jsx(Row, null, __jsx(Col, {\n      sm: 3\n    }, __jsx(\"div\", {\n      style: {\n        width: '20px',\n        height: '20px',\n        backgroundColor: colorScale['WASM_EXPORT'].fill,\n        display: 'inline-block'\n      }\n    }), \"\\xA0\", __jsx(\"span\", null, \"WebAssembly Export\")), __jsx(Col, {\n      sm: 3\n    }, __jsx(\"div\", {\n      style: {\n        width: '20px',\n        height: '20px',\n        backgroundColor: colorScale['WASM_IMPORT'].fill,\n        display: 'inline-block'\n      }\n    }), \"\\xA0\", __jsx(\"span\", null, \"WebAssembly Imported JS Function\")), __jsx(Col, {\n      sm: 3\n    }, __jsx(\"div\", {\n      style: {\n        width: '20px',\n        height: '20px',\n        backgroundColor: colorScale.WASM_INTERNAL.fill,\n        display: 'inline-block'\n      }\n    }), \"\\xA0\", __jsx(\"span\", null, \"WebAssembly Internal Function\")), __jsx(Col, {\n      sm: 3\n    }, __jsx(\"div\", {\n      style: {\n        width: '20px',\n        height: '20px',\n        backgroundColor: colorScale.JS.fill,\n        display: 'inline-block'\n      }\n    }), \"\\xA0\", __jsx(\"span\", null, \"JavaScript Function\"))), __jsx(Row, {\n      style: {\n        position: 'absolute',\n        left: '0',\n        margin: '0',\n        padding: '0',\n        width: '99vw'\n      }\n    }, __jsx(Col, null, __jsx(\"div\", {\n      id: \"graph\",\n      ref: this.graphRef,\n      style: {\n        width: '100%',\n        overflow: 'hidden',\n        border: '1px solid #ececec',\n        borderRadius: '5px'\n      }\n    }))));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}